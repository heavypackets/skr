$directive $target : $input_types -> $output_types { ... }
$function : $input_types -> $output_types { ... } 
$function : $input_types >> $yielded_types { ... }
$function ... |> $function ... 

# Output types can always be ommitted, but will be checked at converge time if specified
# Yielded types must be specified
# ',' commas optional between types in type list, for readability

$input_type <- $value # Currying bind
$input_type = $value # Bind of same type (or enum variant)

$typename.$subtype = $value

#============== Create user
proc create_user : FirstName LastName Email Phone -> User
{
    ApiPermission = ReadWrite
    DiskPermission = ReadOnly

    do {
        create_user -> User
        activate_user 
        set_second_factor_auth

        send_welcome_email : Message <- "Welcome to Zombocom #{User.FullName}"

        send_admin_email : Message <- "New user created"
    }

    commit {
        commit_user : User
    }

    error {}
 
    test intgration1 {
        Description <- "CreateUser_Integration1"

        Commit = False
        ExternalAPI = PartialMock

        when {
            FirstName <- "John"
            LastName <- "Doe"
            Email <- "jon.doe@example.org"
            Phone <- "301.330.7652"

            request get_time : URI <- "http://worldclockapi.com/api/json/est/now" {
                %^"{"$id":"1","currentDateTime":"2018-10-16T14:05-04:00","utcOffset":"-04:00:00","isDayLightSavingsTime":true,"dayOfTheWeek":"Tuesday","timeZoneName":"Eastern Standard Time","currentFileTime":131841723561257240,"ordinalDate":"2018-289","serviceResponse":null}"^
            }
        }
        expect {
            User.FullName == "John Doe"
            User.Username ~= "jdoe"
        }
    }
}

route create_user : FirstName LastName Email Phone
{
    Description = "Create new user"
    Path <- "/user/create"
    ApiPermission = ReadWrite

    do {
        create_user : FirstName LastName Email Phone
    }

    error {}
}

proc email_admin
{
    send_admin_email : Message <- "Hello World"
}

# Explicit
proc create_user : FirstName LastName Email Phone -> User
{
    do {
        create_user : FirstName LastName FullName Email -> User
        activate_user : User
        set_second_factor_auth : User Phone
    
        send_welcome_email : Message <- "Welcome to Zombocom #{User.FullName}"
    
        send_admin_email : Message <- "New user created"
    }
}

#============== Create user with optional types
proc create_user : FirstName %LastName Email Phone %Birthday -> User
{
    do {
        create_user -> User
        activate_user 
        set_second_factor_auth
            
        ~LastName { # Type not present
            send_welcome_email : Message <- "Welcome to Zombocom #{User.FirstName}"
        }

        %LastName { # Type present
            set_user_last_name
            send_welcome_email : Message <- "Welcome to Zombocom #{User.FullName}"
        }

        %Birthday {
            set_user_birthday
        }

        send_admin_email : Message <- "New user created"
    }
}


#============== Upgrade Active Users

proc upgrade_active_users
{
    get_active_users |> each {                                 # |> previous output type will be the input type of the next function
        upgrade_user
        send_user_email : Message <- "You have been upgraded!"
    }

    send_admin_email : Message <- "Users have been upgraded"
}

# No sugar -- Must be explicit about what to iterate over
proc upgrade_active_users -> List<User> 
{
    get_active_users -> List<User>
    each : List<User> {
        upgrade_user User
        send_user_email : User, Message <- "You have been upgraded!"
    }
        
    send_admin_email : Message <- "Users have been upgraded"
}

#============== Upgrade Active Users w/ generator
# get_active_users yields a User and block will concurrently fire on that user
proc upgrade_active_users
{
    gen_active_users >> User {
        upgrade_user
        send_user_email : Message <- "You have been upgraded!"
    }

    send_admin_email : Message <- "Users have been upgraded"
}

# Collect generated values into a List on the context, after operating on yielded value
proc upgrade_active_users -> List<User>
{
    gen_active_users >> User {
        upgrade_user
        send_user_email : Message <- "You have been upgraded!"
    } |> collect # -> List<User>

    send_admin_email : Message <- "Users have been upgraded"
}

#  Multiple yielded types
proc welcome_married_couples
{
    gen_married_couples >> User partner1, User partner2 {
        send_user_email : User partner1, Message <- "Welcome #{partner1.FirstName} and #{partner2.FirstName}!"
        send_user_email : User partner2, Message <- "Welcome #{partner1.FirstName} and #{partner2.FirstName}!"
    }
}

#  Multiple, named yielded types, with named output
proc welcome_married_couples -> List<User> partners
{
    gen_married_couples >> User partner1, User partner2 {
        send_user_email : User partner1, Message <- "Welcome #{partner1.FirstName} and #{partner2.FirstName}!"
        send_user_email : User partner2, Message <- "Welcome #{partner1.FirstName} and #{partner2.FirstName}!"
    } 
    |> collect -> List<User> partner1s, List<User> partner2
    |> flatten -> List<User> partners
    
}

#============== Add user to weekend mailing list

# Query from input parameter
proc add_user_weekend_mailing_list : UserID -> User
{
    get_user_from_id : UserID -> User
    register_user_mail_chimp : MailingList <- Weekend # MailingList::Weekend

    send_user_email : Message <- "Subscribed to emailing list!"
}

#============== Twins Surname

# Named type instances -- needed to remove ambiguity
proc change_twins_surname :
    UserID first_id
    UserID second_id
    LastName -> User first_user
                User second_user 
{
    get_user_from_id : UserID first_id -> User first_user
    set_user_last_name : User first_user

    get_user_from_id : UserID second_id -> User second_user
    set_user_last_name : User second_user
}

# With some sugar -- No need to name return type using |>
proc change_twins_surname : UserID first_id, UserID second_id, LastName -> User
{
    get_user_from_id : first_id
    |> set_user_last_name

    get_user_from_id : second_id
    |> set_user_last_name
}

# Valid use of unneeded named instances
proc change_twins_surname : UserID first_id, UserID second_id, LastName surname
    -> User first_user, User second_user
{
    get_user_from_id : UserID first_id -> User first_user
    set_user_last_name : User first_user, LastName surname

    get_user_from_id : UserID second_id -> User second_user
    set_user_last_name : User second_user, LastName surname
}

# Mutability -- denoted by *Type

# *User is a different type from User
proc set_user_email : *User Email
{
    set_user_email
    send_user_email : Message <- "Password changed"
}

proc set_user_email : *User Email
{
    set_user_email : *User Email # If input types are specified, User must keep its mutability
    send_user_email : Message <- "Password changed"
}

# Mapping

# Map reduce

}